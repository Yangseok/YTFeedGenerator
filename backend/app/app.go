package app

import (
	"archive/zip"
	"bytes"
	"context"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"ytfeedgenerator/backend/database"
	"ytfeedgenerator/backend/models"
	"ytfeedgenerator/backend/services"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type AppService struct {
	DB           *database.DB
	YouTube      *services.YouTubeService
	Transcript   *services.TranscriptService
	LLM          *services.LLMService
	Template     *services.TemplateService
	Notification *services.NotificationService
	Tagging      *services.TaggingService
	Export       *services.ExportService

	syncMu       sync.RWMutex
	syncSettings SyncSettings

	dbPath string
	logger *log.Logger

	summaryMu      sync.Mutex
	summaryRunning bool
}

type SyncResult struct {
	ChannelID     string
	ChannelName   string
	NewVideos     int
	UpdatedVideos int
}

type SyncSettings struct {
	Enabled              bool
	IntervalMinutes      int
	NotificationsEnabled bool
}

type SyncSettingsInput struct {
	Enabled              bool
	IntervalMinutes      int
	NotificationsEnabled bool
}

type SyncSummary struct {
	TotalNew     int
	TotalUpdated int
	Channels     []SyncResult
}

type AppSettings struct {
	LLMProvider            string
	OpenAIKey              string
	OpenAIModel            string
	OllamaURL              string
	ResponseLanguage       string
	SelectedTemplate       string
	AutoSyncEnabled        bool
	SyncIntervalMinutes    int
	NotificationsEnabled   bool
	AutoSummaryEnabled     bool
	SummaryIntervalMinutes int
	SummaryBatchSize       int
}

type AppSettingsInput struct {
	LLMProvider            string
	OpenAIKey              string
	OpenAIModel            string
	OllamaURL              string
	ResponseLanguage       string
	SelectedTemplate       string
	AutoSyncEnabled        bool
	SyncIntervalMinutes    int
	NotificationsEnabled   bool
	AutoSummaryEnabled     bool
	SummaryIntervalMinutes int
	SummaryBatchSize       int
}

type TemplateInput struct {
	Name        string
	Description string
	Prompt      string
	Variables   string
	IsDefault   bool
	CreatedBy   string
}

type SummarizeRequest struct {
	Text         string
	TemplateName string
	Provider     string
	Model        string
	BaseURL      string
	APIKey       string
	Temperature  float64

	Title     string
	Channel   string
	Duration  string
	KeyPoints string
}

type VideoItem struct {
	ID                    uint
	VideoID               string
	Title                 string
	URL                   string
	ChannelID             uint
	ChannelName           string
	Thumbnail             string
	Summary               string
	Transcript            string
	TranscriptStatus      string
	TranscriptLastError   string
	TranscriptLastAttempt *time.Time
	PublishedAt           time.Time
}

type VideoFilter struct {
	ChannelID string
	TagID     uint
	Query     string
}

type CollectionInput struct {
	Name        string
	Description string
}

type CollectionItem struct {
	ID          uint
	Name        string
	Description string
	VideoCount  int64
}

type TagInput struct {
	Name          string
	Color         string
	AutoGenerated bool
}

type TemplateImportResult struct {
	Imported int
	Skipped  int
}

type AutoTagResult struct {
	Tags []models.Tag
	Raw  string
}

type BackupRestoreResult struct {
	BackupPath        string
	RestoredDB        string
	ImportedTemplates int
}

func NewAppService(dbPath string) (*AppService, error) {
	db, err := database.Open(context.Background(), dbPath)
	if err != nil {
		return nil, fmt.Errorf("open db: %w", err)
	}

	if err := db.AutoMigrate(); err != nil {
		return nil, fmt.Errorf("auto migrate: %w", err)
	}

	appService := &AppService{
		DB:           db,
		YouTube:      &services.YouTubeService{},
		Transcript:   &services.TranscriptService{},
		LLM:          &services.LLMService{},
		Template:     &services.TemplateService{},
		Notification: &services.NotificationService{},
		Tagging:      &services.TaggingService{},
		Export:       &services.ExportService{},
		syncSettings: SyncSettings{
			Enabled:              true,
			IntervalMinutes:      30,
			NotificationsEnabled: true,
		},
		dbPath: dbPath,
		logger: newAppLogger(),
	}

	if err := appService.SeedDefaultTemplates(); err != nil {
		return nil, fmt.Errorf("seed templates: %w", err)
	}

	if settings, err := appService.GetAppSettings(); err == nil {
		_, _ = appService.UpdateSyncSettings(SyncSettingsInput{
			Enabled:              settings.AutoSyncEnabled,
			IntervalMinutes:      settings.SyncIntervalMinutes,
			NotificationsEnabled: settings.NotificationsEnabled,
		})
	}

	return appService, nil
}

func (a *AppService) Health(ctx context.Context) string {
	_ = ctx
	return "ok"
}

func (a *AppService) LogClientError(message string) {
	if a.logger == nil {
		return
	}
	msg := strings.TrimSpace(message)
	if msg == "" {
		return
	}
	a.logger.Printf("client: %s", msg)
}

func (a *AppService) GetAppSettings() (AppSettings, error) {
	settings := AppSettings{
		LLMProvider:            getSetting(a.DB, "llm_provider", "ollama"),
		OpenAIModel:            getSetting(a.DB, "openai_model", "gpt-4o-mini"),
		OllamaURL:              getSetting(a.DB, "ollama_url", "http://localhost:11434"),
		ResponseLanguage:       getSetting(a.DB, "response_language", "ko"),
		SelectedTemplate:       getSetting(a.DB, "selected_template", ""),
		AutoSyncEnabled:        getSettingBool(a.DB, "auto_sync_enabled", true),
		SyncIntervalMinutes:    getSettingInt(a.DB, "sync_interval_minutes", 30),
		NotificationsEnabled:   getSettingBool(a.DB, "notifications_enabled", true),
		AutoSummaryEnabled:     getSettingBool(a.DB, "auto_summary_enabled", false),
		SummaryIntervalMinutes: getSettingInt(a.DB, "summary_interval_minutes", 60),
		SummaryBatchSize:       getSettingInt(a.DB, "summary_batch_size", 3),
	}
	enc := getSetting(a.DB, "openai_key", "")
	if enc != "" {
		if dec, err := decryptString(enc); err == nil {
			settings.OpenAIKey = dec
		}
	}
	return settings, nil
}

func (a *AppService) SaveAppSettings(input AppSettingsInput) (AppSettings, error) {
	setSetting(a.DB, "llm_provider", input.LLMProvider)
	setSetting(a.DB, "openai_model", input.OpenAIModel)
	setSetting(a.DB, "ollama_url", input.OllamaURL)
	if strings.TrimSpace(input.ResponseLanguage) != "" {
		setSetting(a.DB, "response_language", input.ResponseLanguage)
	}
	if strings.TrimSpace(input.SelectedTemplate) != "" {
		setSetting(a.DB, "selected_template", input.SelectedTemplate)
	}
	setSetting(a.DB, "auto_sync_enabled", fmt.Sprintf("%t", input.AutoSyncEnabled))
	setSetting(a.DB, "sync_interval_minutes", fmt.Sprintf("%d", input.SyncIntervalMinutes))
	setSetting(a.DB, "notifications_enabled", fmt.Sprintf("%t", input.NotificationsEnabled))
	setSetting(a.DB, "auto_summary_enabled", fmt.Sprintf("%t", input.AutoSummaryEnabled))
	if input.SummaryIntervalMinutes > 0 {
		setSetting(a.DB, "summary_interval_minutes", fmt.Sprintf("%d", input.SummaryIntervalMinutes))
	}
	if input.SummaryBatchSize > 0 {
		setSetting(a.DB, "summary_batch_size", fmt.Sprintf("%d", input.SummaryBatchSize))
	}
	if strings.TrimSpace(input.OpenAIKey) != "" {
		if enc, err := encryptString(input.OpenAIKey); err == nil {
			setSetting(a.DB, "openai_key", enc)
		}
	}
	_, _ = a.UpdateSyncSettings(SyncSettingsInput{
		Enabled:              input.AutoSyncEnabled,
		IntervalMinutes:      input.SyncIntervalMinutes,
		NotificationsEnabled: input.NotificationsEnabled,
	})
	return a.GetAppSettings()
}

func (a *AppService) GetSyncSettings() SyncSettings {
	a.syncMu.RLock()
	defer a.syncMu.RUnlock()
	return a.syncSettings
}

func (a *AppService) UpdateSyncSettings(input SyncSettingsInput) (SyncSettings, error) {
	interval := input.IntervalMinutes
	if interval <= 0 {
		interval = 30
	}
	if interval > 1440 {
		interval = 1440
	}
	settings := SyncSettings{
		Enabled:              input.Enabled,
		IntervalMinutes:      interval,
		NotificationsEnabled: input.NotificationsEnabled,
	}
	a.syncMu.Lock()
	a.syncSettings = settings
	a.syncMu.Unlock()
	return settings, nil
}

func (a *AppService) ListChannels() ([]models.Channel, error) {
	var channels []models.Channel
	if err := a.DB.Gorm.Order("name asc").Find(&channels).Error; err != nil {
		return nil, err
	}
	return channels, nil
}

func (a *AppService) DeleteChannel(channelID string) error {
	if strings.TrimSpace(channelID) == "" {
		return fmt.Errorf("channelID is required")
	}

	var channel models.Channel
	if err := a.DB.Gorm.Where("channel_id = ?", channelID).First(&channel).Error; err != nil {
		return err
	}

	// Remove channel and associated videos
	if err := a.DB.Gorm.Where("channel_id = ?", channel.ID).Delete(&models.Video{}).Error; err != nil {
		return err
	}
	return a.DB.Gorm.Delete(&channel).Error
}

func (a *AppService) ListVideos(limit, offset int, filter VideoFilter) ([]VideoItem, error) {
	if limit <= 0 {
		limit = 50
	}
	if offset < 0 {
		offset = 0
	}

	queryText := strings.TrimSpace(filter.Query)
	channelID := strings.TrimSpace(filter.ChannelID)

	var videos []VideoItem
	dbQuery := a.DB.Gorm.Table("videos").
		Select("distinct videos.id, videos.video_id, videos.title, videos.url, videos.channel_id, channels.name as channel_name, videos.thumbnail, videos.summary, videos.transcript, videos.transcript_status, videos.transcript_last_error, videos.transcript_last_attempt, videos.published_at").
		Joins("left join channels on channels.id = videos.channel_id")

	if channelID != "" {
		dbQuery = dbQuery.Where("channels.channel_id = ?", channelID)
	}

	if filter.TagID != 0 {
		dbQuery = dbQuery.Joins("inner join video_tags on video_tags.video_id = videos.id").
			Where("video_tags.tag_id = ?", filter.TagID)
	}

	if queryText != "" {
		like := "%" + strings.ToLower(queryText) + "%"
		dbQuery = dbQuery.Where(
			"(lower(videos.title) like ? or lower(videos.summary) like ? or lower(channels.name) like ?)",
			like, like, like,
		)
	}

	if err := dbQuery.
		Order("videos.published_at desc").
		Limit(limit).
		Offset(offset).
		Scan(&videos).Error; err != nil {
		return nil, err
	}

	return videos, nil
}

func (a *AppService) ListTemplates() ([]models.Template, error) {
	var templates []models.Template
	if err := a.DB.Gorm.Order("is_default desc, name asc").Find(&templates).Error; err != nil {
		return nil, err
	}
	if len(templates) == 0 {
		if err := a.SeedDefaultTemplates(); err != nil {
			if a.logger != nil {
				a.logger.Printf("seed templates on empty: %v", err)
			}
			return templates, nil
		}
		if err := a.DB.Gorm.Order("is_default desc, name asc").Find(&templates).Error; err != nil {
			return nil, err
		}
	}
	return templates, nil
}

func (a *AppService) ListCollections() ([]CollectionItem, error) {
	var collections []models.Collection
	if err := a.DB.Gorm.Order("created_at desc").Find(&collections).Error; err != nil {
		return nil, err
	}

	items := make([]CollectionItem, 0, len(collections))
	for _, c := range collections {
		var count int64
		if err := a.DB.Gorm.Table("collection_videos").Where("collection_id = ?", c.ID).Count(&count).Error; err != nil {
			return nil, err
		}
		items = append(items, CollectionItem{
			ID:          c.ID,
			Name:        c.Name,
			Description: c.Description,
			VideoCount:  count,
		})
	}
	return items, nil
}

func (a *AppService) ListTags() ([]models.Tag, error) {
	var tags []models.Tag
	if err := a.DB.Gorm.Order("name asc").Find(&tags).Error; err != nil {
		return nil, err
	}
	return tags, nil
}

func (a *AppService) CreateTag(input TagInput) (models.Tag, error) {
	name := strings.TrimSpace(input.Name)
	if name == "" {
		return models.Tag{}, fmt.Errorf("tag name is required")
	}
	tag := models.Tag{
		Name:          name,
		Color:         input.Color,
		AutoGenerated: input.AutoGenerated,
		CreatedAt:     time.Now(),
	}
	if err := a.DB.Gorm.Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "name"}},
		DoUpdates: clause.AssignmentColumns([]string{"color", "auto_generated"}),
	}).Create(&tag).Error; err != nil {
		return models.Tag{}, err
	}
	return tag, nil
}

func (a *AppService) DeleteTag(id uint) error {
	if id == 0 {
		return fmt.Errorf("tag id is required")
	}
	return a.DB.Gorm.Delete(&models.Tag{}, id).Error
}

func (a *AppService) AddTagToVideo(videoID string, tagID uint) error {
	if strings.TrimSpace(videoID) == "" || tagID == 0 {
		return fmt.Errorf("videoID and tagID are required")
	}
	var video models.Video
	if err := a.DB.Gorm.Where("video_id = ?", videoID).First(&video).Error; err != nil {
		return err
	}
	var tag models.Tag
	if err := a.DB.Gorm.Where("id = ?", tagID).First(&tag).Error; err != nil {
		return err
	}
	return a.DB.Gorm.Model(&video).Association("Tags").Append(&tag)
}

func (a *AppService) RemoveTagFromVideo(videoID string, tagID uint) error {
	if strings.TrimSpace(videoID) == "" || tagID == 0 {
		return fmt.Errorf("videoID and tagID are required")
	}
	var video models.Video
	if err := a.DB.Gorm.Where("video_id = ?", videoID).First(&video).Error; err != nil {
		return err
	}
	var tag models.Tag
	if err := a.DB.Gorm.Where("id = ?", tagID).First(&tag).Error; err != nil {
		return err
	}
	return a.DB.Gorm.Model(&video).Association("Tags").Delete(&tag)
}

func (a *AppService) CreateCollection(input CollectionInput) (models.Collection, error) {
	name := strings.TrimSpace(input.Name)
	if name == "" {
		return models.Collection{}, fmt.Errorf("collection name is required")
	}

	collection := models.Collection{
		Name:        name,
		Description: input.Description,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}
	if err := a.DB.Gorm.Create(&collection).Error; err != nil {
		return models.Collection{}, err
	}
	return collection, nil
}

func (a *AppService) DeleteCollection(id uint) error {
	if id == 0 {
		return fmt.Errorf("collection id is required")
	}
	if err := a.DB.Gorm.Where("collection_id = ?", id).Delete(&models.CollectionVideo{}).Error; err != nil {
		return err
	}
	return a.DB.Gorm.Delete(&models.Collection{}, id).Error
}

func (a *AppService) AddVideoToCollection(collectionID uint, videoID string) error {
	if collectionID == 0 || strings.TrimSpace(videoID) == "" {
		return fmt.Errorf("collectionID and videoID are required")
	}
	var video models.Video
	if err := a.DB.Gorm.Where("video_id = ?", videoID).First(&video).Error; err != nil {
		return err
	}
	link := models.CollectionVideo{
		CollectionID: collectionID,
		VideoID:      video.ID,
	}
	return a.DB.Gorm.Clauses(clause.OnConflict{DoNothing: true}).Create(&link).Error
}

func (a *AppService) RemoveVideoFromCollection(collectionID uint, videoID string) error {
	if collectionID == 0 || strings.TrimSpace(videoID) == "" {
		return fmt.Errorf("collectionID and videoID are required")
	}
	var video models.Video
	if err := a.DB.Gorm.Where("video_id = ?", videoID).First(&video).Error; err != nil {
		return err
	}
	return a.DB.Gorm.Where("collection_id = ? AND video_id = ?", collectionID, video.ID).Delete(&models.CollectionVideo{}).Error
}

func (a *AppService) ListCollectionVideos(collectionID uint) ([]VideoItem, error) {
	if collectionID == 0 {
		return nil, fmt.Errorf("collectionID is required")
	}
	var videos []VideoItem
	if err := a.DB.Gorm.Table("videos").
		Select("videos.id, videos.video_id, videos.title, videos.url, videos.channel_id, channels.name as channel_name, videos.thumbnail, videos.summary, videos.published_at").
		Joins("left join channels on channels.id = videos.channel_id").
		Joins("inner join collection_videos on collection_videos.video_id = videos.id").
		Where("collection_videos.collection_id = ?", collectionID).
		Order("videos.published_at desc").
		Scan(&videos).Error; err != nil {
		return nil, err
	}
	return videos, nil
}

func (a *AppService) ExportCollectionMarkdown(collectionID uint) (string, error) {
	if collectionID == 0 {
		return "", fmt.Errorf("collectionID is required")
	}
	var collection models.Collection
	if err := a.DB.Gorm.Where("id = ?", collectionID).First(&collection).Error; err != nil {
		return "", err
	}
	videos, err := a.ListCollectionVideos(collectionID)
	if err != nil {
		return "", err
	}

	content := fmt.Sprintf("# %s\n\n%s\n\n", collection.Name, collection.Description)
	for _, v := range videos {
		content += fmt.Sprintf("## %s\n\n", v.Title)
		content += fmt.Sprintf("- Channel: %s\n", v.ChannelName)
		content += fmt.Sprintf("- Published: %s\n", v.PublishedAt.Format(time.RFC3339))
		content += fmt.Sprintf("- URL: %s\n\n", v.URL)
		if v.Summary != "" {
			content += fmt.Sprintf("%s\n\n", v.Summary)
		}
	}

	return a.Export.ExportMarkdown(context.Background(), content, "exports", fmt.Sprintf("collection-%d.md", collectionID))
}

func (a *AppService) ExportCollectionPDF(collectionID uint) (string, error) {
	if collectionID == 0 {
		return "", fmt.Errorf("collectionID is required")
	}
	var collection models.Collection
	if err := a.DB.Gorm.Where("id = ?", collectionID).First(&collection).Error; err != nil {
		return "", err
	}
	videos, err := a.ListCollectionVideos(collectionID)
	if err != nil {
		return "", err
	}

	content := fmt.Sprintf("%s\n\n%s\n\n", collection.Name, collection.Description)
	for _, v := range videos {
		content += fmt.Sprintf("%s\n", v.Title)
		content += fmt.Sprintf("Channel: %s\n", v.ChannelName)
		content += fmt.Sprintf("Published: %s\n", v.PublishedAt.Format(time.RFC3339))
		content += fmt.Sprintf("URL: %s\n\n", v.URL)
		if v.Summary != "" {
			content += fmt.Sprintf("%s\n\n", v.Summary)
		}
	}

	return a.Export.ExportPDF(context.Background(), content, "exports", fmt.Sprintf("collection-%d.pdf", collectionID))
}

func (a *AppService) SaveTemplate(input TemplateInput) (models.Template, error) {
	if strings.TrimSpace(input.Name) == "" {
		return models.Template{}, fmt.Errorf("template name is required")
	}
	if strings.TrimSpace(input.Prompt) == "" {
		return models.Template{}, fmt.Errorf("template prompt is required")
	}

	template := models.Template{
		Name:        strings.TrimSpace(input.Name),
		Description: input.Description,
		Prompt:      input.Prompt,
		Variables:   input.Variables,
		IsDefault:   input.IsDefault,
		CreatedBy:   input.CreatedBy,
		CreatedAt:   time.Now(),
	}

	if err := a.DB.Gorm.Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "name"}},
		DoUpdates: clause.AssignmentColumns([]string{"description", "prompt", "variables", "is_default", "created_by"}),
	}).Create(&template).Error; err != nil {
		return models.Template{}, err
	}

	var saved models.Template
	if err := a.DB.Gorm.Where("name = ?", template.Name).First(&saved).Error; err != nil {
		return models.Template{}, err
	}
	return saved, nil
}

func (a *AppService) DeleteTemplate(name string) error {
	if strings.TrimSpace(name) == "" {
		return fmt.Errorf("template name is required")
	}
	return a.DB.Gorm.Where("name = ?", name).Delete(&models.Template{}).Error
}

func (a *AppService) SeedDefaultTemplates() error {
	templates := []TemplateInput{
		{
			Name:        "Simple Summary",
			Description: "3-line summary",
			Prompt:      "Summarize the following content in 3 concise lines:\\n\\n{text}",
			Variables:   `["text"]`,
			IsDefault:   true,
			CreatedBy:   "system",
		},
		{
			Name:        "Detailed Summary",
			Description: "Key points + details",
			Prompt:      "Provide key points and a detailed summary.\\nTitle: {title}\\nChannel: {channel}\\n\\nContent:\\n{text}",
			Variables:   `["title","channel","text"]`,
			IsDefault:   true,
			CreatedBy:   "system",
		},
		{
			Name:        "News Style",
			Description: "Headline + lead + body",
			Prompt:      "Write a news-style summary with a headline, lead sentence, and body.\\n\\n{text}",
			Variables:   `["text"]`,
			IsDefault:   true,
			CreatedBy:   "system",
		},
		{
			Name:        "Lecture Notes",
			Description: "Outline + key notes + recap",
			Prompt:      "Create lecture notes with an outline, key notes, and a recap.\\nTitle: {title}\\n\\n{text}",
			Variables:   `["title","text"]`,
			IsDefault:   true,
			CreatedBy:   "system",
		},
		{
			Name:        "Quick Review",
			Description: "Pros/Cons + verdict",
			Prompt:      "Summarize as a quick review: pros, cons, and final verdict.\\n\\n{text}",
			Variables:   `["text"]`,
			IsDefault:   true,
			CreatedBy:   "system",
		},
	}

	for _, tpl := range templates {
		if _, err := a.SaveTemplate(tpl); err != nil {
			return err
		}
	}
	return nil
}

func (a *AppService) ResetDefaultTemplates() error {
	return a.SeedDefaultTemplates()
}

func (a *AppService) ExportTemplates() (string, error) {
	templates, err := a.ListTemplates()
	if err != nil {
		return "", err
	}
	raw, err := json.MarshalIndent(templates, "", "  ")
	if err != nil {
		return "", err
	}
	return string(raw), nil
}

func (a *AppService) ImportTemplates(raw string, overwrite bool) (TemplateImportResult, error) {
	if strings.TrimSpace(raw) == "" {
		return TemplateImportResult{}, fmt.Errorf("template json is required")
	}

	var inputs []TemplateInput
	if err := json.Unmarshal([]byte(raw), &inputs); err != nil {
		var existing []models.Template
		if err2 := json.Unmarshal([]byte(raw), &existing); err2 != nil {
			return TemplateImportResult{}, fmt.Errorf("invalid template json")
		}
		for _, tpl := range existing {
			inputs = append(inputs, TemplateInput{
				Name:        tpl.Name,
				Description: tpl.Description,
				Prompt:      tpl.Prompt,
				Variables:   tpl.Variables,
				IsDefault:   tpl.IsDefault,
				CreatedBy:   tpl.CreatedBy,
			})
		}
	}

	result := TemplateImportResult{}
	for _, tpl := range inputs {
		if strings.TrimSpace(tpl.Name) == "" || strings.TrimSpace(tpl.Prompt) == "" {
			result.Skipped++
			continue
		}

		if !overwrite {
			var count int64
			if err := a.DB.Gorm.Model(&models.Template{}).Where("name = ?", tpl.Name).Count(&count).Error; err == nil && count > 0 {
				result.Skipped++
				continue
			}
		}

		if strings.TrimSpace(tpl.CreatedBy) == "" {
			tpl.CreatedBy = "import"
		}
		if _, err := a.SaveTemplate(tpl); err != nil {
			return result, err
		}
		result.Imported++
	}
	return result, nil
}

func (a *AppService) SummarizeText(req SummarizeRequest) (string, error) {
	if strings.TrimSpace(req.Text) == "" {
		return "", fmt.Errorf("text is required")
	}
	template, err := a.getTemplateByName(req.TemplateName)
	if err != nil {
		return "", err
	}

	prompt := applyTemplate(template.Prompt, req)
	systemPrompt := "You are a helpful assistant that summarizes YouTube content."
	if settings, err := a.GetAppSettings(); err == nil {
		prompt = applyResponseLanguage(prompt, settings.ResponseLanguage)
		systemPrompt = applySystemLanguage(systemPrompt, settings.ResponseLanguage)
	}
	return a.LLM.Chat(context.Background(), services.LLMRequest{
		Provider:     req.Provider,
		Model:        req.Model,
		BaseURL:      req.BaseURL,
		APIKey:       req.APIKey,
		SystemPrompt: systemPrompt,
		UserPrompt:   prompt,
		Temperature:  req.Temperature,
	})
}

func (a *AppService) AutoTagVideo(videoID string, provider string, model string, baseURL string, apiKey string, temperature float64) (AutoTagResult, error) {
	if strings.TrimSpace(videoID) == "" {
		return AutoTagResult{}, fmt.Errorf("videoID is required")
	}

	var video models.Video
	if err := a.DB.Gorm.Where("video_id = ?", videoID).First(&video).Error; err != nil {
		return AutoTagResult{}, err
	}

	text := strings.TrimSpace(video.Summary)
	if text == "" {
		text = strings.TrimSpace(video.Transcript)
	}
	if text == "" {
		transcript, err := a.Transcript.FetchTranscript(context.Background(), video.VideoID, []string{"ko", "en"})
		if err == nil && strings.TrimSpace(transcript) != "" {
			text = transcript
			_ = a.DB.Gorm.Model(&models.Video{}).Where("id = ?", video.ID).Update("transcript", transcript).Error
		}
	}
	if strings.TrimSpace(text) == "" {
		return AutoTagResult{}, fmt.Errorf("no text available to tag")
	}

	prompt := "Extract 5 to 8 short tags from the following content. " +
		"Return ONLY a JSON array of strings. Use concise nouns or noun phrases.\n\n" + text
	if settings, err := a.GetAppSettings(); err == nil {
		prompt = applyTagLanguage(prompt, settings.ResponseLanguage)
	}

	raw, err := a.LLM.Chat(context.Background(), services.LLMRequest{
		Provider:     provider,
		Model:        model,
		BaseURL:      baseURL,
		APIKey:       apiKey,
		SystemPrompt: "You generate concise tags for content.",
		UserPrompt:   prompt,
		Temperature:  temperature,
	})
	if err != nil {
		return AutoTagResult{}, err
	}

	tags := parseTagList(raw)
	if len(tags) == 0 {
		return AutoTagResult{Raw: raw}, nil
	}

	created := make([]models.Tag, 0, len(tags))
	for _, name := range tags {
		name = strings.TrimSpace(name)
		if name == "" {
			continue
		}
		tag := models.Tag{
			Name:          name,
			Color:         "",
			AutoGenerated: true,
			CreatedAt:     time.Now(),
		}
		if err := a.DB.Gorm.Clauses(clause.OnConflict{
			Columns:   []clause.Column{{Name: "name"}},
			DoUpdates: clause.AssignmentColumns([]string{"auto_generated"}),
		}).Create(&tag).Error; err != nil {
			return AutoTagResult{}, err
		}
		var saved models.Tag
		if err := a.DB.Gorm.Where("name = ?", name).First(&saved).Error; err != nil {
			return AutoTagResult{}, err
		}
		_ = a.DB.Gorm.Model(&video).Association("Tags").Append(&saved)
		created = append(created, saved)
	}
	return AutoTagResult{Tags: created, Raw: raw}, nil
}

func (a *AppService) ExportBackup() (BackupRestoreResult, error) {
	timestamp := time.Now().Format("20060102-150405")
	if err := os.MkdirAll("backups", 0o755); err != nil {
		return BackupRestoreResult{}, err
	}
	path := filepath.Join("backups", fmt.Sprintf("backup-%s.zip", timestamp))

	file, err := os.Create(path)
	if err != nil {
		return BackupRestoreResult{}, err
	}
	defer file.Close()

	zipWriter := zip.NewWriter(file)
	defer zipWriter.Close()

	if a.dbPath != "" {
		if dbBytes, err := os.ReadFile(a.dbPath); err == nil {
			if w, err := zipWriter.Create("ytfeed.db"); err == nil {
				_, _ = w.Write(dbBytes)
			}
		}
	}

	if settings, err := a.GetAppSettings(); err == nil {
		if raw, err := json.MarshalIndent(settings, "", "  "); err == nil {
			if w, err := zipWriter.Create("settings.json"); err == nil {
				_, _ = w.Write(raw)
			}
		}
	}

	if templates, err := a.ExportTemplates(); err == nil {
		if w, err := zipWriter.Create("templates.json"); err == nil {
			_, _ = w.Write([]byte(templates))
		}
	}

	return BackupRestoreResult{BackupPath: path}, nil
}

func (a *AppService) ImportBackup(path string, restoreDB bool) (BackupRestoreResult, error) {
	if strings.TrimSpace(path) == "" {
		return BackupRestoreResult{}, fmt.Errorf("backup path is required")
	}
	raw, err := os.ReadFile(path)
	if err != nil {
		return BackupRestoreResult{}, err
	}

	reader, err := zip.NewReader(bytes.NewReader(raw), int64(len(raw)))
	if err != nil {
		return BackupRestoreResult{}, err
	}

	result := BackupRestoreResult{}
	for _, f := range reader.File {
		switch f.Name {
		case "settings.json":
			if content, err := readZipFile(f); err == nil {
				var settings AppSettingsInput
				if err := json.Unmarshal(content, &settings); err == nil {
					_, _ = a.SaveAppSettings(settings)
				}
			}
		case "templates.json":
			if content, err := readZipFile(f); err == nil {
				if res, err := a.ImportTemplates(string(content), true); err == nil {
					result.ImportedTemplates = res.Imported
				}
			}
		case "ytfeed.db":
			if restoreDB {
				if content, err := readZipFile(f); err == nil && a.dbPath != "" {
					restorePath := a.dbPath + ".restore"
					if err := os.WriteFile(restorePath, content, 0o644); err == nil {
						result.RestoredDB = restorePath
					}
				}
			}
		}
	}

	return result, nil
}

func (a *AppService) SummarizeVideo(videoID string, templateName string, provider string, model string, baseURL string, apiKey string, temperature float64) (string, error) {
	if strings.TrimSpace(videoID) == "" {
		return "", fmt.Errorf("videoID is required")
	}

	var video models.Video
	if err := a.DB.Gorm.Where("video_id = ?", videoID).First(&video).Error; err != nil {
		return "", err
	}

	var channel models.Channel
	if err := a.DB.Gorm.Where("id = ?", video.ChannelID).First(&channel).Error; err != nil {
		return "", err
	}

	text := video.Transcript
	if strings.TrimSpace(text) == "" {
		if skip, wait := shouldSkipTranscriptFetch(video); skip {
			waitMinutes := int(wait.Round(time.Minute).Minutes())
			if waitMinutes < 1 {
				waitMinutes = 1
			}
			return "", fmt.Errorf("transcript retry cooldown active (%d minutes remaining)", waitMinutes)
		}
		now := time.Now()
		_ = a.DB.Gorm.Model(&models.Video{}).Where("id = ?", video.ID).Updates(map[string]interface{}{
			"transcript_last_attempt": &now,
		}).Error
		transcript, err := a.Transcript.FetchTranscript(context.Background(), video.VideoID, []string{"ko", "en"})
		if err == nil && strings.TrimSpace(transcript) != "" {
			text = transcript
			_ = a.DB.Gorm.Model(&models.Video{}).Where("id = ?", video.ID).Updates(map[string]interface{}{
				"transcript":              transcript,
				"transcript_status":       "ok",
				"transcript_last_error":   "",
				"transcript_last_attempt": &now,
			}).Error
		} else if err != nil {
			status := "failed"
			if strings.Contains(err.Error(), "429") {
				status = "rate_limited"
			}
			_ = a.DB.Gorm.Model(&models.Video{}).Where("id = ?", video.ID).Updates(map[string]interface{}{
				"transcript_status":       status,
				"transcript_last_error":   err.Error(),
				"transcript_last_attempt": &now,
			}).Error
		}
	}
	if strings.TrimSpace(text) == "" {
		return "", fmt.Errorf("transcript not available for this video")
	}

	summary, err := a.SummarizeText(SummarizeRequest{
		Text:         text,
		TemplateName: templateName,
		Provider:     provider,
		Model:        model,
		BaseURL:      baseURL,
		APIKey:       apiKey,
		Temperature:  temperature,
		Title:        video.Title,
		Channel:      channel.Name,
	})
	if err != nil {
		return "", err
	}

	if err := a.DB.Gorm.Model(&models.Video{}).Where("id = ?", video.ID).Update("summary", summary).Error; err != nil {
		return "", err
	}

	return summary, nil
}

func (a *AppService) SyncChannelFeed(channelID string) (SyncResult, error) {
	ctx := context.Background()
	feed, err := a.YouTube.FetchChannelFeed(ctx, channelID)
	if err != nil {
		return SyncResult{}, err
	}

	now := time.Now()
	channel := models.Channel{
		ChannelID:   feed.ChannelID,
		Name:        feed.ChannelName,
		URL:         feed.ChannelURL,
		Description: "",
		UpdatedAt:   now,
	}

	if err := a.DB.Gorm.Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "channel_id"}},
		DoUpdates: clause.AssignmentColumns([]string{"name", "url", "thumbnail", "description", "updated_at"}),
	}).Create(&channel).Error; err != nil {
		return SyncResult{}, err
	}

	var channelRecord models.Channel
	if err := a.DB.Gorm.Where("channel_id = ?", feed.ChannelID).First(&channelRecord).Error; err != nil {
		return SyncResult{}, err
	}

	newCount := 0
	updatedCount := 0

	for _, entry := range feed.Entries {
		video := models.Video{
			VideoID:     entry.VideoID,
			Title:       entry.Title,
			URL:         entry.URL,
			ChannelID:   channelRecord.ID,
			Thumbnail:   entry.Thumbnail,
			PublishedAt: entry.PublishedAt,
			UpdatedAt:   now,
		}

		var existing models.Video
		err := a.DB.Gorm.Where("video_id = ?", entry.VideoID).First(&existing).Error
		if err == nil {
			updatedCount++
		} else if err == gorm.ErrRecordNotFound {
			newCount++
		} else if err != nil {
			return SyncResult{}, err
		}

		if err := a.DB.Gorm.Clauses(clause.OnConflict{
			Columns:   []clause.Column{{Name: "video_id"}},
			DoUpdates: clause.AssignmentColumns([]string{"title", "url", "thumbnail", "published_at", "channel_id", "updated_at"}),
		}).Create(&video).Error; err != nil {
			return SyncResult{}, err
		}
	}

	return SyncResult{
		ChannelID:     feed.ChannelID,
		ChannelName:   feed.ChannelName,
		NewVideos:     newCount,
		UpdatedVideos: updatedCount,
	}, nil
}

func (a *AppService) SyncAllChannels() (SyncSummary, error) {
	channels, err := a.ListChannels()
	if err != nil {
		return SyncSummary{}, err
	}

	summary := SyncSummary{
		Channels: make([]SyncResult, 0, len(channels)),
	}

	for _, channel := range channels {
		result, err := a.SyncChannelFeed(channel.ChannelID)
		if err != nil {
			return summary, err
		}
		summary.TotalNew += result.NewVideos
		summary.TotalUpdated += result.UpdatedVideos
		summary.Channels = append(summary.Channels, result)
	}
	return summary, nil
}

func (a *AppService) AutoSummarizePending() (int, error) {
	a.summaryMu.Lock()
	if a.summaryRunning {
		a.summaryMu.Unlock()
		return 0, nil
	}
	a.summaryRunning = true
	a.summaryMu.Unlock()
	defer func() {
		a.summaryMu.Lock()
		a.summaryRunning = false
		a.summaryMu.Unlock()
	}()

	settings, err := a.GetAppSettings()
	if err != nil {
		return 0, err
	}

	provider := settings.LLMProvider
	if provider == "" {
		provider = "ollama"
	}
	model := settings.OpenAIModel
	baseURL := settings.OllamaURL
	apiKey := settings.OpenAIKey
	if provider == "openai" {
		if strings.TrimSpace(apiKey) == "" {
			return 0, fmt.Errorf("openai api key is required for auto summary")
		}
		if model == "" {
			model = "gpt-4o-mini"
		}
		baseURL = "https://api.openai.com"
	} else {
		if model == "" {
			model = "llama3"
		}
		if strings.TrimSpace(baseURL) == "" {
			baseURL = "http://localhost:11434"
		}
	}

	templateName := settings.SelectedTemplate
	if strings.TrimSpace(templateName) == "" {
		templateName = ""
	}
	batch := settings.SummaryBatchSize
	if batch <= 0 {
		batch = 3
	}

	limit := batch * 5
	if limit < batch {
		limit = batch
	}
	if limit > 50 {
		limit = 50
	}

	var videos []models.Video
	if err := a.DB.Gorm.Where("summary = '' OR summary IS NULL").Order("published_at desc").Limit(limit).Find(&videos).Error; err != nil {
		return 0, err
	}

	count := 0
	for _, v := range videos {
		_, err := a.SummarizeVideo(v.VideoID, templateName, provider, model, baseURL, apiKey, 0.4)
		if err != nil {
			if strings.Contains(err.Error(), "cooldown") {
				continue
			}
			if a.logger != nil {
				a.logger.Printf("auto summary failed: %s: %v", v.VideoID, err)
			}
			continue
		}
		count++
		if count >= batch {
			break
		}
	}
	return count, nil
}

func (a *AppService) getTemplateByName(name string) (models.Template, error) {
	if strings.TrimSpace(name) == "" {
		var tpl models.Template
		if err := a.DB.Gorm.Where("is_default = ?", true).Order("name asc").First(&tpl).Error; err != nil {
			return models.Template{}, fmt.Errorf("no default template found")
		}
		return tpl, nil
	}

	var tpl models.Template
	if err := a.DB.Gorm.Where("name = ?", name).First(&tpl).Error; err != nil {
		return models.Template{}, err
	}
	return tpl, nil
}

func applyTemplate(prompt string, req SummarizeRequest) string {
	replacer := strings.NewReplacer(
		"{title}", req.Title,
		"{channel}", req.Channel,
		"{duration}", req.Duration,
		"{key_points}", req.KeyPoints,
		"{summary}", req.Text,
		"{text}", req.Text,
	)
	return replacer.Replace(prompt)
}

func applyResponseLanguage(prompt string, lang string) string {
	lang = strings.ToLower(strings.TrimSpace(lang))
	switch lang {
	case "ko", "kr", "korean":
		return "IMPORTANT: 답변은 반드시 한국어로만 작성해 주세요.\n\n" + prompt + "\n\n응답은 반드시 한국어로 작성해 주세요."
	case "en", "english":
		return "IMPORTANT: Please respond only in English.\n\n" + prompt + "\n\nPlease respond in English."
	default:
		return prompt
	}
}

func applySystemLanguage(prompt string, lang string) string {
	lang = strings.ToLower(strings.TrimSpace(lang))
	switch lang {
	case "ko", "kr", "korean":
		return prompt + " You MUST respond only in Korean."
	case "en", "english":
		return prompt + " You MUST respond only in English."
	default:
		return prompt
	}
}

func shouldSkipTranscriptFetch(video models.Video) (bool, time.Duration) {
	if video.TranscriptLastAttempt == nil {
		return false, 0
	}
	status := strings.ToLower(strings.TrimSpace(video.TranscriptStatus))
	elapsed := time.Since(*video.TranscriptLastAttempt)
	if status == "rate_limited" {
		const cooldown = 6 * time.Hour
		if elapsed < cooldown {
			return true, cooldown - elapsed
		}
	}
	if status == "failed" {
		const cooldown = 30 * time.Minute
		if elapsed < cooldown {
			return true, cooldown - elapsed
		}
	}
	return false, 0
}

func applyTagLanguage(prompt string, lang string) string {
	lang = strings.ToLower(strings.TrimSpace(lang))
	switch lang {
	case "ko", "kr", "korean":
		return prompt + "\n\n태그는 한국어로 작성해 주세요."
	case "en", "english":
		return prompt + "\n\nProvide tags in English."
	default:
		return prompt
	}
}

func parseTagList(raw string) []string {
	raw = strings.TrimSpace(raw)
	if raw == "" {
		return nil
	}
	var tags []string
	if err := json.Unmarshal([]byte(raw), &tags); err == nil {
		return tags
	}
	raw = strings.TrimPrefix(raw, "Tags:")
	raw = strings.Trim(raw, "[]")
	parts := strings.FieldsFunc(raw, func(r rune) bool {
		return r == ',' || r == '\n' || r == ';'
	})
	for _, p := range parts {
		p = strings.TrimSpace(strings.Trim(p, `"'`))
		if p != "" {
			tags = append(tags, p)
		}
	}
	return tags
}

func readZipFile(f *zip.File) ([]byte, error) {
	rc, err := f.Open()
	if err != nil {
		return nil, err
	}
	defer rc.Close()
	return io.ReadAll(rc)
}

func newAppLogger() *log.Logger {
	if err := os.MkdirAll("logs", 0o755); err != nil {
		return log.New(os.Stdout, "", log.LstdFlags)
	}
	file, err := os.OpenFile("logs/app.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o644)
	if err != nil {
		return log.New(os.Stdout, "", log.LstdFlags)
	}
	return log.New(file, "", log.LstdFlags)
}

func setSetting(db *database.DB, key string, value string) {
	if db == nil {
		return
	}
	if strings.TrimSpace(key) == "" {
		return
	}
	record := models.AppSetting{
		Key:       key,
		Value:     value,
		UpdatedAt: time.Now(),
	}
	_ = db.Gorm.Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "key"}},
		DoUpdates: clause.AssignmentColumns([]string{"value", "updated_at"}),
	}).Create(&record).Error
}

func getSetting(db *database.DB, key string, fallback string) string {
	if db == nil || strings.TrimSpace(key) == "" {
		return fallback
	}
	var record models.AppSetting
	if err := db.Gorm.Where("key = ?", key).First(&record).Error; err != nil {
		return fallback
	}
	if strings.TrimSpace(record.Value) == "" {
		return fallback
	}
	return record.Value
}

func getSettingBool(db *database.DB, key string, fallback bool) bool {
	val := strings.ToLower(strings.TrimSpace(getSetting(db, key, "")))
	if val == "" {
		return fallback
	}
	return val == "true" || val == "1" || val == "yes"
}

func getSettingInt(db *database.DB, key string, fallback int) int {
	val := strings.TrimSpace(getSetting(db, key, ""))
	if val == "" {
		return fallback
	}
	var out int
	_, err := fmt.Sscanf(val, "%d", &out)
	if err != nil || out == 0 {
		return fallback
	}
	return out
}

func encryptString(input string) (string, error) {
	key := deriveDeviceKey()
	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}
	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return "", err
	}
	ciphertext := gcm.Seal(nil, nonce, []byte(input), nil)
	combined := append(nonce, ciphertext...)
	return base64.StdEncoding.EncodeToString(combined), nil
}

func decryptString(input string) (string, error) {
	key := deriveDeviceKey()
	raw, err := base64.StdEncoding.DecodeString(input)
	if err != nil {
		return "", err
	}
	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", err
	}
	if len(raw) < gcm.NonceSize() {
		return "", fmt.Errorf("invalid ciphertext")
	}
	nonce := raw[:gcm.NonceSize()]
	ciphertext := raw[gcm.NonceSize():]
	plain, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return "", err
	}
	return string(plain), nil
}

func deriveDeviceKey() []byte {
	id := loadMachineID()
	sum := sha256.Sum256([]byte("ytfg:" + id))
	return sum[:]
}

func loadMachineID() string {
	if raw, err := os.ReadFile("/etc/machine-id"); err == nil {
		id := strings.TrimSpace(string(raw))
		if id != "" {
			return id
		}
	}
	host, _ := os.Hostname()
	if host != "" {
		return host
	}
	return "ytfg-default"
}
